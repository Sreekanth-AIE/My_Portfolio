<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Services vs Controllers ‚Äî Clear, Practical, and Funny</title>
  <meta name="description" content="A practical guide for backend developers: when to use controllers and when to use services, with dev humor and memes." />
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; max-width:760px; margin:40px auto; line-height:1.6; color:#111; padding:0 20px; }
    h1 { font-size:28px; margin-bottom:6px; }
    h2 { font-size:22px; margin-top:32px; border-bottom: 1px solid #eee; padding-bottom: 4px; }
    h3 { font-size: 18px; margin-top: 24px;}
    pre { 
        background:#f6f8fa; 
        padding:12px; 
        border-radius:6px; 
        overflow-x:auto; 
        font-family: 'Consolas', 'Monaco', monospace; 
        font-size: 14px;
        line-height: 1.4;
    }
    table { width: 100%; border-collapse: collapse; margin: 20px 0; font-size: 14px; }
    th, td { border: 1px solid #ddd; padding: 10px; text-align: left; }
    th { background-color: #f2f2f2; }
    .meme { display:block; margin:24px auto; max-width:100%; height: auto; border-radius:6px; box-shadow:0 6px 18px rgba(0,0,0,0.08); }
    .caption { font-size:13px; color:#555; text-align:center; margin-top:8px; margin-bottom: 18px; font-style: italic; }
    .note { background:#fffbe6; border-left:4px solid #ffd54d; padding:10px 12px; border-radius:4px; margin:18px 0; }
    footer { margin-top:60px; color:#666; font-size:13px; border-top: 1px solid #eee; padding-top: 20px; }
    .small { font-size:13px; color:#666; }
  </style>
</head>
<body>
  <header>
    <h1>Services vs Controllers: Why the split matters (and how to keep your sanity)</h1>
    <p class="small">Estimated read: 4‚Äì5 minutes ‚Ä¢ Written for backend devs who prefer practical rules over theory.</p>
  </header>

  <section>
    <h2>What each layer is ‚Äî plain and useful</h2>
    <p>Imagine your backend as a <strong>restaurant</strong>. The <strong>Controller</strong> is the <strong>host</strong> who greets the customer, validates their ID, takes their order, and sends it to the kitchen. The <strong>Service</strong> is the <strong>kitchen</strong> ‚Äî it knows how to cook the dish, call the pantry (database), and plate the meal.</p>
    <p>Controllers should be <strong>thin</strong>: accept requests, validate input format, call services, and format responses. Services should hold <strong>business rules</strong>, data orchestration, and the side effects (DB queries, external API calls).</p>
  </section>

  <figure>
    <img class="meme" src="/blogs/svsc/assets/no-god-please-no-no.gif" alt="Michael Scott Noooo" />
    <figcaption class="caption">When you open a controller and find 500 lines of business logic. <strong>Nooooo!</strong> (source: The Office / Michael Scott Noooo)</figcaption>
  </figure>

  <section>
    <h2>Concrete Responsibilities and Why the Split Helps</h2>
    <table>
      <thead>
        <tr>
          <th>Component</th>
          <th>Responsibility (What it does)</th>
          <th>Practical Gain (Why it matters)</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Controller</strong></td>
          <td>Handle <strong>HTTP details</strong> (route mapping, <strong>light</strong> auth checks, input schema validation, status codes).</td>
          <td><strong>Readability:</strong> Quickly understand the API's intent ("what").</td>
        </tr>
        <tr>
          <td><strong>Service</strong></td>
          <td>Implement <strong>business processes</strong> (complex domain logic, calling repositories, transactions, external API retries, business-specific validation).</td>
          <td><strong>Testability:</strong> Can be unit tested in isolation without a server (by using 'mocks' for dependencies like the database).</td>
        </tr>
        <tr>
          <td><strong>Repository/DAO</strong></td>
          <td><strong>Raw DB access</strong> (all queries and persistence details).</td>
          <td><strong>Reusability:</strong> Business logic can be reused by multiple consumers (e.g., other controllers, scheduled jobs).</td>
        </tr>
      </tbody>
    </table>

    <div class="note">
      Quick tip: If you want to unit test something without spinning up a server, it belongs in the <strong>service layer</strong>.
    </div>
  </section>

  <figure>
    <img class="meme" src="/blogs/svsc/assets/iron-man.gif" alt="I am Iron Man - Iron Man" />
    <figcaption class="caption">Services when you mock dependencies properly for testing. <strong>I am Iron Man.</strong> (source: Marvel / Iron Man)</figcaption>
  </figure>

  <section>
    <h2>Quick, Practical Patterns</h2>
    <p>Here are the patterns I use in production code for the <strong>Model-Service-Controller</strong> approach:</p>
    <ol>
      <li><strong>Controller is thin:</strong> Validate input and pass a Data Transfer Object (<strong>DTO</strong>) to the service.</li>
      <li><strong>Service returns domain objects:</strong> Controller maps them to HTTP response DTOs.</li>
      <li><strong>Repository/DAO handles raw DB access:</strong> Keep SQL or ORM queries in one place for maintainability.</li>
      <li><strong>Keep transactions in the service:</strong> Orchestrate multiple repository calls inside a service transaction rather than the controller.</li>
    </ol>

    <h3>üõ†Ô∏è TypeScript Code Examples</h3>

    <pre><code>// user.controller.ts
import { Request, Response } from 'express';
import * as userService from './user.service';
// Assume UserCreateRequest and UserResponse are DTO interfaces defined elsewhere
// import { UserCreateRequest, UserResponse } from './user.dto'; 

export const createUser = async (req: Request, res: Response) => {
  const payload = req.body; // Input validation (e.g., Joi/Zod) should run before here
  try {
    const userDomainObject = await userService.createUser(payload);
    
    // Controller maps the internal domain object to the public response DTO
    const response = { id: userDomainObject.id, email: userDomainObject.email };

    res.status(201).json(response);
  } catch (err) {
    // A robust error handling middleware should handle this in a real app
    res.status(400).json({ error: (err as Error).message });
  }
};
    </code></pre>

    <pre><code>// user.service.ts
import * as userRepo from './user.repo';

// Example of a minimal domain object shape
interface UserDomain {
  id: string;
  email: string;
}

export const createUser = async (data: { email: string; name?: string }): Promise<UserDomain> => {
  // 1. Business Validation
  if (!data.email.includes('@')) { 
    throw new Error('Email must be a valid format.');
  }

  // 2. Data Orchestration / Business Logic
  const userData = { ...data, createdAt: new Date() };

  // 3. Persistence Call
  return await userRepo.insert(userData);
};
    </code></pre>
  </section>

  <section>
    <h2>Common Anti-Patterns (and how to fix them)</h2>
    <ul>
      <li><strong>The God Controller:</strong> A controller with hundreds of lines of code. <strong>Fix:</strong> Refactor logic into multiple, small, focused <strong>Service</strong> classes; extract helper modules for repeated logic.</li>
      <li><strong>Controller doing retries / complex flows:</strong> Any sequence of steps or logic that isn't purely HTTP response shaping. <strong>Fix:</strong> Move to the <strong>Service layer</strong> or specialized middleware depending on the scope.</li>
      <li><strong>Direct DB access from controllers:</strong> Never put raw queries or ORM calls directly in the controller file. <strong>Fix:</strong> Always route persistence operations through a dedicated <strong>Repository</strong> or <strong>DAO</strong> layer.</li>
    </ul>
  </section>

  <figure>
    <img class="meme" src="/blogs/svsc/assets/giphy.gif" alt="Gandalf You Shall Not Pass" />
    <figcaption class="caption">When a junior dev tries to put raw DB queries in a controller. <strong>You Shall Not Pass!</strong> (source: The Lord of the Rings / Gandalf)</figcaption>
  </figure>

  <section>
    <h2>Real-world checklist before you write code</h2>
    <p>Use these three questions to immediately decide where your code belongs:</p>
    <ol>
      <li>Can this be tested without an HTTP server? If <strong>yes</strong>, it belongs in the <strong>Service</strong>.</li>
      <li>Does it manipulate multiple persistence layers or external APIs? <strong>Service</strong>.</li>
      <li>Is it purely about request/response shape, path mapping, or auth headers? <strong>Controller</strong>.</li>
    </ol>
    <p>Stick that checklist above your Pull Request template and watch reviewers gain 20% less blood pressure.</p>
  </section>

  <figure>
    <img class="meme" src="/blogs/svsc/assets/meme5.jpg" alt="Leonardo DiCaprio Cheers" />
    <figcaption class="caption">When your controllers are tidy and your services have solid tests. Cheers. (source: The Great Gatsby / Leonardo DiCaprio)</figcaption>
  </figure>

  <footer>
    <p class="small">This content was created to provide practical guidance on backend architecture patterns.</p>
  </footer>
</body>
</html>